![favicon](./images/favicon.jpg)

> ☝️ 이 문서는 파비콘(Favicon) 자원을 캐시하게 된 이유와, 캐시의 합리성을 검토한 뒤 최종적으로 캐시하지 않기로 판단한 근거를 정리한 문서입니다.

<br />

## I. 최초 로드 이후에도, 페이지 이동 시마다 파비콘(Favicon) 자원이 재요청되는 현상

프로젝트를 개발하던 과정에서 TimeZoneDB API를 통해 도시 시계 목록을 조회하는 로직이 있었기 때문에, 해당 요청의 응답 헤더와 본문을 확인하기 위해 개발자 도구의 Network 탭을 확인했습니다.

그러나 이 과정에서 브라우저가 요청하는 자원 목록을 살펴보던 중, `favicon.svg` 정적 자원이 아래 이미지와 같이 최초 로드 이후에도 페이지 이동 시마다 반복적으로 재요청되는 현상을 확인하게 되었습니다.

![최초 요청 시 요청 목록](./images/first-request.png)

> _해당 이미지는 최초 페이지 로드 시 브라우저가 요청한 전체 네트워크 요청 목록을 보여주는 Network 탭 화면입니다._

<br />

![페이지 이동 시마다 반복적으로 재요청되는 favicon 자원](./images/re-request-favicon.png)

> _해당 이미지는 페이지 이동 시마다 `favicon.svg` 자원이 반복적으로 재요청되는 현상을 확인하기 위해, 관련 요청(other 항목)만 필터링하여 표시한 Network 탭 화면입니다._

<br />

이미지를 통해 확인할 수 있듯이, 페이지를 이동할 때마다 `favicon.svg` 자원이 반복적으로 재요청되고 있었습니다. 또한 해당 자원이 캐시되지 않았기 때문에, 요청이 완료되기까지 걸리는 전체 소요 시간이 매번 달라지는 현상이 나타났습니다. 특히 일부 재요청의 경우, 정적 자원임에도 불구하고 최대 243ms까지 소요되는 비교적 큰 네트워크 지연이 발생하는 것을 확인할 수 있었습니다.

이로 인해서, 소요 시간이 가장 오래 걸린 요청이 어떤 단계에서 지연되고 있는지를 분석하기 위해, 다음 이미지와 같이 해당 요청의 상세 패널의 Timing 탭을 열어 확인하였습니다.

![최대 소요 시간 파비콘 timing 탭](./images/favicon-timing.png)

<br />

최대 243ms가 소요된 파비콘 요청의 상세 패널에서 Timing 탭을 확인해 보면, 전체 지연의 대부분이 Waiting for server response 단계(239.77ms)에서 발생한 것을 확인할 수 있습니다. 이 구간은 "요청이 서버로 전송된 이후, 서버가 요청을 처리하고 응답의 첫 번째 바이트(TTFB)를 생성할 때까지 소요된 시간"을 의미합니다.

하지만 해당 프로젝트는 직접 웹 서버를 구축한 환경이 아니라 Vercel을 통해 배포된 구조였기 때문에, 이 구간의 서버 처리(TTFB)에 대해 개발자가 직접 접근하거나 내부 제어할 수 있는 수단이 없었습니다. 또한, 이 지연을 애플리케이션 레벨에서 개선할 수 있는 방법을 별도로 찾지도 못한 상태였습니다.

<br />

## II. React 기반의 웹 애플리케이션 렌더링 과정

> 📌 이 목차에서는 브라우저 렌더링 과정, SPA(Single-Page Application) 등의 내용을 요약하여 설명합니다. 다소 분량이 많기 때문에, 파비콘 자원이 재요청되는 원인만 확인하고 싶다면 다음 목차로 넘어가셔도 됩니다.

["I. 최초 로드 이후에도, 페이지 이동 시마다 파비콘(Favicon) 자원이 재요청되는 현상"](#i-최초-로드-이후에도-페이지-이동-시마다-파비콘favicon-자원이-재요청되는-현상) 목차에서 설명한 문제를 해결하기에 앞서, 먼저 이 현상이 왜 발생하고 있는지를 파악하기로 했습니다.

현재 진행 중인 Clock 프로젝트는 React + TypeScript + Vite 기반의 SPA(Single-Page Application) 구조로 개발된 웹 애플리케이션으로, 최초 페이지 로드 이후에는 페이지 이동이 발생하더라도 HTML 문서가 다시 요청되지 않고, JavaScript가 메모리로 추상화하여 관리하는 Virtual DOM의 변경 사항만 실제 DOM에 반영하는 CSR(Client-Side Rendering) 방식으로 동작하기 때문에, 페이지 이동 시마다 파비콘과 같은 정적 자원이 다시 요청되는 이유를 이해하기 어려웠기 때문입니다.

<br />

### A. 브라우저 동작･렌더링 과정

![브라우저 렌더링 과정](./images/browser-rendering.webp)

> 브라우저 동작･렌더링 과정에 대해 보다 자세한 내용은, 제 기술 블로그의 [Notion: 브라우저 동작 원리](https://gye-won.notion.site/Browser-Workflow-2ae88bd9c3fa80b8a33dc4b869c180ec?pvs=74) 포스트를 참고해 주시기 바랍니다.

<br />

많은 프론트엔드 개발자는 브라우저의 동작･렌더링 과정을 이해하고 프로젝트를 진행하게 됩니다. 간단하게 브라우저 동작･렌더링 과정을 설명하자면 다음과 같이 동작을 하게 됩니다.

- 사용자가 URL에 최초 접속 시 브라우저 구성 요소 중 사용자 인터페이스는 이를 감지하여 렌더링을 위해 브라우저 엔진(UI와 렌더링 엔진 사이에서 발생한 동작을 중재하는 엔진)에 전달하고 렌더링 엔진(웹 서버로부터 전달받은 HTML 문서를 해석하여 브라우저 화면에 표시하는 역할을 수행하는 엔진)에 전달하게 됩니다.
- URL을 전달받은 렌더링 엔진은 브라우저의 다른 구성 요소인 통신 모듈에 URL을 넘긴 후 통신 모듈은 DNS, TCP/IP 연결 과정을 진행하여 웹 서버로부터 해당 도메인의 정적 자원(HTML, CSS, JavaScript)을 전달받고 렌더링 엔진에게 다시 전달한다.
- 이후, 렌더링 엔진은 전달받은 HTML 문서와 CSS 자원을 각각 DOM과 CSSOM으로 변환 시킨 후 이 둘을 결합하여 Render Tree를 생성하여 요소의 크기, 위치 등을 계산하는 Layout 단계를 수행하고, 요소의 색상, 그림자 등의 시각적 속성을 픽셀 단위로 계산하기 위한 Paint 작업을 수행하고, 수행된 결과물들을 결합하는 Composite 단계를 수행하여 실제 화면에 출력하기 위해 UI 백엔드에 넘겨준다.
- UI 백엔드는 Render Tree 기반으로 계산된 요소의 위치, 크기, 색상 등을 브라우저 화면에 실제로 그리기 위해 GPU 및 OS 그래픽 시스템과 연동하여 실제 화면을 그리는 작업을 수행하고, 최종적으로 브라우저 뷰포트에 HTML 문서를 해석한 결과물이 렌더링된다.

<br />

### B. SPA(Single-Page Application)

![SPA-MPA](./images/spa-mpa.webp)

> SPA(Single-Page Application) & MPA(Multi-Page Application)에 대해 보다 자세한 내용은, 제 기술 블로그의 [Notion: SPA & MPA](https://gye-won.notion.site/SPA-MPA-29888bd9c3fa801d94b7c17a2fbb2799) 포스트를 참고해 주시기 바랍니다.

<br />

브라우저는 앞서 설명한 동작 원리에 따라 HTML, CSS, JavaScript 자원을 받아 렌더링을 수행합니다. 그렇다면 React 강의나 책에서 가장 먼저 등장하는 SPA(Single-Page Application)는 무엇을 의미할까요? 그건 바로 웹 애플리케이션이 하나의 HTML 문서를 기반으로 동작하는 구조를 의미합니다.

일반적인 웹 사이트에서는 사용자가 여러 페이지를 이동할 때마다 서로 다른 HTML 문서가 서버로부터 전달됩니다. 이러한 방식으로 여러 HTML 페이지를 통해 웹 사이트를 구성하는 구조를 MPA(Multi-Page Application)라고 부릅니다. 이 경우 페이지가 전환될 때마다 브라우저는 새로운 HTML 문서를 요청하고, 이에 포함된 CSS, JavaScript 등의 정적 자원을 다시 받아 전체 렌더링 과정을 수행하게 됩니다.

반면, React, Vue, Angular와 같은 프레임워크는 기본적으로 SPA 구조를 기반으로 합니다. 즉, 애플리케이션은 최초 접속 시 하나의 HTML 문서만 로드하고, 이후의 화면 전환은 이 HTML 문서를 교체하지 않은 채 JavaScript를 통해 화면을 동적으로 변경하는 방식으로 이루어집니다. 이러한 동작 방식은 [CSR(Client-Side Rendering)](https://gye-won.notion.site/CSR-Client-Side-Rendering-23688bd9c3fa811dab4fd1cbf549c3e6?pvs=74)과 [클라이언트 사이드 라우팅(Client-Side Routing)](https://gye-won.notion.site/Client-Side-Routing-29a88bd9c3fa80e9a67ddae3a6cddc5e)에 의해 가능해지며, 이에 대한 자세한 내용은 제 기술 블로그의 노션 포스트를 참고해 주시기 바랍니다.

중요한 점은, 현재 개발 중인 Clock 프로젝트 역시 이러한 SPA 구조를 따르고 있기 때문에, 사용자가 최초 접속 시 전달받은 HTML 문서는 이후 페이지 이동이 발생하더라도 변경되지 않는다는 것입니다. 즉, 페이지 전환 시마다 새로운 HTML 정적 자원을 다시 요청하는 과정이 발생하지 않고, JavaScript가 메모리 상에서 관리하는 Virtual DOM의 변경 사항만 실제 DOM에 반영되어 화면이 갱신됩니다.

이와 같은 구조를 고려할 때, 페이지 이동이 발생하더라도 HTML 문서가 다시 로드되지 않는 SPA 환경에서 `favicon.svg`와 같은 정적 자원이 반복적으로 재요청되는 현상은 저는 잘 이해가 되지 않았습니다.

<br />

## III. SPA 구조에서 `favicon.svg` 파일이 재요청되는 이유와 캐시 설정

앞서 ["II. React 기반의 웹 애플리케이션 렌더링 과정"](#ii-react-기반의-웹-애플리케이션-렌더링-과정) 목차에서, SPA 환경에서는 페이지 이동이 발생하더라도 HTML 문서가 다시 요청되지 않기 때문에 `favicon.svg`와 같은 정적 자원이 반복적으로 요청되는 현상이 직관적으로 이해되지 않는다는 점을 서술했습니다. 그럼에도 불구하고, 이 문제의 원인과 해결 방법을 알고 싶었기 때문에 Stack Overflow와 Raddit 등 개발자 커뮤니티에서 관련 정보를 얻기 위해 노력했습니다.

그러나 이와 관련된 정보를 단순한 검색만으로는 정확히 파악하기 어려웠습니다. 대부분의 파비콘(Favicon) 관련 자료는 "이전 파비콘이 유지되어 변경되지 않는 문제"에 대한 결과에 초점이 맞춰져 있었고, SPA 환경에서 파비콘이 반복적으로 재요청되는 현상을 다루는 사례는 거의 찾아볼 수 없었기 때문입니다. 그래서 이 문제를 검색으로 문제를 파악하기 어렵다고 판단하여 ChatGPT에 해당 문제를 질문하였고, 다음과 같은 답변을 얻을 수 있었습니다.

```md
질문: "React 기반 SPA에서 라우트가 변경됨에도 불구하고 favicon.svg를 재요청이 발생하는 이유가 머야?"
```

```md
답변: "SPA에서의 라우트 변경은 React 입장에서는 컴포넌트 교체일 뿐이지만, 브라우저 입장에서는 주소창의 URL이 변경된 상태 입니다.
브라우저는 URL이 바뀌면 해당 탭의 상태를 동기화하기 위해 현재 문서 내의 메타데이터(파비콘 등)를 재평가 합니다.
이 과정에서 브라우저가 <link rel="icon"> 태그를 다시 확인하게 되고, favicon.svg에 대한 네트워크 요청(캐시 확인 포함)이 발생하게 됩니다."
```

SPA(Single-Page Application) 환경에서는 해시 기반(Fragment Mode) 또는 히스토리 기반(History API Mode)의 클라이언트 사이드 라우팅(Client-Side Routing)을 통해 페이지가 전환되더라도 새로운 HTML 문서를 서버에 요청하지 않고 내부 구성 요소만 변경됩니다. 그러나 브라우저는 URL이 변경된 상태이기 때문에, 해당 탭의 상태를 동기화하기 위해 현재 문서에 연결된 메타데이터가 다시 평가하게 되고, 그 결과 `favicon.svg`와 같은 정적 자원이 재요청되고 있었던 것입니다.

즉, 이 현상은 브라우저의 동작 원리나 SPA 구조에 대한 이해 부족으로 발생한 문제가 아니라, 브라우저가 탭의 상태를 유지･동기화하기 위해 문서 메타데이터를 재평가하는 정상적인 동작이었습니다. 원인을 파악한 이후에는, 재요청으로 인해 발생하는 서버 응답 지연을 줄이기 위해 `favicon.svg`에 대해 최초 응답 시 `Cache-Control` 헤더를 설정하여, 이후 요청이 발생하더라도 서버가 아닌 웹 캐시(Disk Cache)에서 자원을 재사용하도록 구성하면 된다는 점을 알 수 있었습니다.

```jsonc
// 웹 서버를 직접 구축한 것이 아닌 Vercel을 통해 배포되어, Vercel에서 구성된 웹 서버를 사용하게 됩니다.
// 이로 인해, 정적 자원의 응답 헤더를 지정하기 위해서는 vercel.json에서 자원을 선택하여 value를 설정해줘야 합니다.
{
  // ...
  "headers": [
    {
      "source": "/favicon.svg",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ]
}
```

![Favicon memory cache](./images/favicon-memory-cahce.png)

<br />

위와 같이 `favicon.svg`의 응답 헤더에 캐시 정책을 설정한 후 Network 탭을 확인해 보면, 해당 자원이 브라우저 캐시에서 관리되는 것을 확인할 수 있습니다.

그 결과, URL 변경으로 인해 재요청이 발생하더라도 서버로 네트워크 요청을 보내지 않고 메모리에서 즉시 응답이 반환되며, 응답 시간이 기존 최대 243ms에서 최대 5ms 수준으로 크게 감소한 것을 확인할 수 있었습니다.