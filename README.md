## ⏰ JGW Clock App

JGW Clock App은 iPhone 시계 앱을 모바일 화면 크기를 기준으로 제작된 웹앱 형태로 클론 코딩한 프로젝트입니다.

<br />

## ⚙️ JGW Clock App - FE Skills

||||||
|--|--|--|--|--|
|![React](/public/icons/react.svg)|![TypeScript](/public/icons/typescript.svg)|![SCSS](/public/icons/sass.svg)|![Vite](https://www.svgrepo.com/show/354521/vitejs.svg)|![Vercel](/public/icons/vercel.svg)|
|React|TypeScript|SCSS|Vite|Vercel|

<br />

## 📝 JGW Clock App - Documents

> **⭐️ 문서들을 읽기 전에 반드시 참고해주세요**

Clock 프로젝트는 처음 포트폴리오에 추가할 목적으로 시작한 간단한 토이 프로젝트였습니다. 초기에는 별도의 디자인 시안이 없었기 때문에, iOS 모바일 기기의 **"시계" 앱 UI**를 기반으로 개발을 시작했고, 점차 클론 코딩 형태로 확장되며 프로젝트가 진행되었습니다.

이로 인해 프로젝트를 진행하면서 단순히 기능 구현에 그치지 않고, 지금까지 개발자가 되기 위해 공부해 온 내용을 바탕으로 코드를 작성하며, **"현재 작성된 이 로직은 어떤 원리로 동작하는가?"**, **"더 나은 구조와 더 나은 코드로 개선할 수는 없을까?"** 라는 질문을 스스로에게 계속 던지게 되었고, 그 과정에서 코드를 점진적으로 개선해 나가는 과정이 자연스럽게 프로젝트에 녹아들게 되었습니다.

또한 기술 선택에 있어서도, 과거처럼 "유행이기 때문에", "많은 기업이 사용하기 때문에"라는 이유로 기술을 선택하기보다는, **이 기술이 현재 구조에서 합리적인 선택인지**, **다른 기술과 비교했을 때 어떤 점이 더 적절한지**, **지금 이 상황에 정말 필요한 선택인지** 등의 고려하며 기술 스택을 고민하고 결정하는 사고 과정 역시 문서에 함께 담게 되었습니다.

아울러 문서를 작성하는 과정에서, 또는 문서를 정리한 이후에 드러난 단순한 오해로 인해 발생했던 시행착오와 실수들 또한 그대로 기록되어 있습니다.

이러한 이유로, 아래에 정리된 문서들은 단순히 포트폴리오용 결과물을 정리한 문서라기보다는, 개발자로서의 사고 과정과 학습 과정, 그리고 성장 과정을 기록한 문서에 더 가깝습니다. 물론 포트폴리오에 포함되기는 하지만, 개인적으로는 이 프로젝트를 **"성과 중심의 포트폴리오 프로젝트"** 라기보다 **"성장 기록 중심의 프로젝트"** 로 바라보고 있습니다.

따라서 아래 링크로 연결된 각 문서들은 분량이 길고, 개인적인 사고 과정과 주관적인 판단이 많이 포함되어 있어 읽는 데 다소 부담스럽게 느껴질 수도 있습니다.

<br />

|문서|설명|
|:--|:--|
|[FSD 아키텍처](/docs/fsd-architecture.md)|이전까지 설계한 디렉토리 구조의 문제점과 FSD 아키텍처를 도입한 이유를 설명하는 문서입니다.|
|[FSD 아키텍처 문제점](/docs/fsd-layer-problem.md)|FSD 아키텍처를 도입하고 개인적으로 발생한 문제를 설명하는 문서입니다.|
|[도시 시간 계산 로직 리팩토링 과정](/docs/city-time-calculation-refactoring.md)|기존 도시 시간 계산 로직의 문제점을 분석하고, 리팩토링 과정을 단계적으로 설명한 문서입니다.|
|[Timer 로직 리팩토링 과정](/docs/timer-refactoring.md)|타이머 페이지에서 사용되는 useTimer 커스텀 훅 로직의 문제점을 분석하고, 리팩토링 과정을 단계적으로 설명한 문서입니다.|
|[헤더 제어 로직 리팩토링 과정](/docs/header-controls-refactoring.md)|기존 useHeaderControls 로직을 분석하여, 책임을 어떻게 분리하고 FSD 아키텍처 구조에 맞게 수정한 과정을 설명한 문서입니다.|
|[SCSS 구조 리팩토링 과정](/docs/scss-refactoring.md)|프로젝트 개발 완료 이후, 기존 SCSS 스타일시트 코드를 분석하고 이를 기반으로 리팩토링을 진행한 과정을 단계적으로 정리한 문서입니다.|
|[API Key 보호를 위한 Vercel 서버리스 함수 도입 과정](/docs/vercel-functions-integration.md)|프로젝트 개발 완료 이후, **List Time Zone API의 API Key가 요청 경로에 노출되어 있는 문제를 파악**하고, 이를 해결하기 위해 **Vercel 서버리스 함수를 도입한 과정**을 설명한 문서입니다. 또한 **서버리스 함수 도입에 따라 기존에 IndexedDB를 이용해 브라우저 캐시 저장소를 대체하던 방식**을 유지하지 않고, `Cache-Control` 응답 헤더를 통해 **캐싱 전략을 수정한 내용도 함께 다루고 있습니다.**|
|[Intl API 기반 도시 간 시차 계산 로직 리팩토링](/docs/time-zone-convert-refactoring.md)|기존 **Convert Time Zone API의 네트워크 응답에 의존하던 시차 계산 구조**를 **Intl API 기반 클라이언트 계산 방식으로 리팩토링**하여, **네트워크 환경에 따른 응답 지연 문제를 개선**한 성능 최적화 과정을 정리한 문서입니다.|
|[Lighthouse SEO 점수 개선 및 Google Search Console 사이트 등록](/docs/seo-optimization.md)|개발자 도구 Lighthouse를 활용해 **SEO 점수를 100점으로 개선**한 후, 사이트를 **Google 및 Naver 검색엔진에 노출시키기 위한 선정 이유**와 **Google Search Console 등록 과정**을 정리한 문서입니다.|
|[~~동일한 데이터 재요청 문제 분석 및 IndexedDB 캐싱 도입 과정~~](/docs/time-zone-db-list-request-caching.md)|Vercel 서버리스 함수를 도입하기 이전, **List Time Zone API의 응답 헤더에 `Cache-Control`이 설정되어 있지 않아 동일한 데이터임에도 반복적인 재요청이 발생하는 문제를 분석**하고, **성능 개선을 위해 IndexedDB 기반 캐싱 과정을 도입한 내용을 정리한 문서**입니다. 다만 **Vercel 서버리스 함수 도입 이후 해당 방식의 필요성이 줄어들어 캐싱 전략을 수정**하였으나, 개발에는 정답이 존재하지 않고, **상황에 맞는 해결 전략을 선택하는 과정 자체에 의미가 있다고 판단**하여 **본 문서를 그대로 보존하기로 결정한 문서**입니다.|
|[~~파비콘 자원 재요청으로 인한 성능 최적화~~](/docs/favicon-cahcing.md)|**파비콘 파일명 오타로 인해 발생한 문제를 인지하지 못한 상태에서 진행된 분석 기록을 정리한 문서**입니다. 비록 실제 원인은 **단순한 오타**였지만, 문제를 해결하는 과정에서 **개발자 도구를 활용한 분석 방법**과 **스스로 기준을 세워 판단에 이르는 사고 과정**이 잘 드러나 있어, 참고 자료로서 **삭제하지 않고 그대로 남겨두기로 결정한 문서**입니다.|
